---
description: >-
  Generates any unprovided resolvers for query and mutation types that are
  generated or that use a @cypher directive.
---

# buildNeo4jResolvers

## API Reference

* `typeDefs` \(required\): Your GraphQL type definitions in [SDL format](https://www.prisma.io/blog/graphql-sdl-schema-definition-language-6755bcb9ce51/). 
* `resolvers`\(required\): A resolvers object to augment. 
* `query` \(default: `true`\): A Boolean controlling whether to generate resolvers for query types. 
* `mutation` \(default: `true`\): A Boolean controlling whether to generate resolvers for mutation types. 
* `bindingKey` \(default: 'neo4j'\) The key of the binding \(stored in your server's context object\) to be used within generated resolvers for operation delegation.

## Example

```javascript
import { buildNeo4jResolvers } from 'neo4j-graphql-binding';
​
const typeDefs = `
  type Technology @model {
    name: String! @unique
    integration: [Technology] @relation(name: "HAPPINESS", direction: OUT)
    integrationCount: Int @cypher(statement: """ 
      MATCH (this)-[:HAPPINESS]->(t:Technology)
      RETURN count(t)
    """)
  }
  type Query {
    Technology: [Technology] @cypher(statement: """
      MATCH (t:Technology) RETURN t
    """)
  }
  type Mutation {
    deleteTechnology(id: ID!): Boolean @cypher(statement: """
      MATCH (t: Technology {id: $id})
      DETACH DELETE t
      RETURN TRUE
    """)
  }
  schema {
    query: Query
    mutation: Mutation
  }
`;
​
const augmented = buildNeo4jResolvers({
  typeDefs: typeDefs,
  driver: driver
});
```

For every `query` or `mutation` type using a `@cypher` directive, or for those generated by `buildNeo4jTypeDefs`, a resolver will be created if one is not provided_._

```javascript
Query: {
  Technology: (obj, params, ctx, info) => {
    return ctx.neo4j.query.Technology(params, info);
  }
},
Mutation: {
  createTechnology: (obj, params, ctx, info) => {
    return ctx.neo4j.mutation.createTechnology(params, info);
  },
  deleteTechnology: (obj, params, ctx, info) => {
    return ctx.neo4j.mutation.deleteTechnology(params, info);
  }
}
```

